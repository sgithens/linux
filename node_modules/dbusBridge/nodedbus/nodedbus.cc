/*
 * GPII Node.js DBus Bridge
 *
 * Copyright 2012 Emergya
 * Author: Javier Hern√°ndez <jhernandez@emergya.com>
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/gpii/universal/LICENSE.txt
 * */

#include <gio/gio.h>
#include <stdlib.h>
#include <json-glib/json-glib.h>

#include <node.h>
#include <v8.h>

using namespace v8;

/**
 * get_g_variant_boolean:
 * 
 * Should take as argument: A V8 Boolean Value
 * Returns: The GVariant representation of the Boolean
 */
static GVariant *
get_g_variant_boolean (Handle<Value> value){
  return g_variant_new("b",value->BooleanValue());
}

/**
 * get_g_variant_number:
 * 
 * Should take as argument: A V8 Number Value
 * Returns: The GVariant representation of the Number
 */
static GVariant *
get_g_variant_number (Handle<Value> value){
  return g_variant_new("i",value->NumberValue());
}

/**
 * get_g_variant_string:
 * 
 * Should take as argument: A V8 String Value
 * Returns: The GVariant representation of the String
 */
static GVariant *
get_g_variant_string (Handle<Value> value){
  char str_value[1024];
  value->ToString()->WriteUtf8(str_value);
  return g_variant_new("s",str_value);
}

/**
 * get_g_variant_array:
 *
 * Should take as argument: A V8 Array Value
 * Returns: The GVariant representation of the Array
 */
static GVariant *
get_g_variant_array (Handle<Value> value) {
  GVariantBuilder builder;
  GVariant *out_value;
  Handle<Array> array = Handle<Array>::Cast(value);
  int array_length = array->Length();

  if (array_length==0) {
    g_printerr ("ERROR: Wrong array length detected while parsing arguments\n");
    ThrowException(Exception::Error(String::New("Wrong array length")));
  }

  g_variant_builder_init (&builder, G_VARIANT_TYPE_TUPLE);
 
  int i;

  for(i=0;i<array_length;i++){
    GVariant *g_value;
    Handle<Value> val = array->Get(i);

    if (val->IsBoolean()) {
      g_value = get_g_variant_boolean (val);
    } else if (val->IsNumber()) {
      g_value = get_g_variant_number (val);
    } else if (val->IsString()) {
      g_value = get_g_variant_string (val);
    } else if (val->IsArray()){
      g_value = get_g_variant_array (val);
    } else {
      ThrowException(Exception::Error(String::New("We haven't implemented this type yet!")));
    }

    g_variant_builder_add_value (&builder, g_value);
  }

  out_value = g_variant_builder_end(&builder);
  return out_value;
}

/**
 * get_g_variant_value:
 *
 * Should take as argument: A V8 Value
 * Returns: The GVariant representation of the Value
 */
static GVariant *
get_g_variant_value (Handle<Value> value) {
  GVariant *arguments;

  if (value->IsBoolean()) {
    arguments = g_variant_new("(b)",value->BooleanValue());
  } else if (value->IsNumber()) {
    arguments = g_variant_new("(i)",value->NumberValue());
  } else if (value->IsString()) {
    char str_value[1024];
    value->ToString()->WriteAscii(str_value);
    arguments = g_variant_new("(s)",str_value);
  } else if (value->IsArray()) {
    arguments = get_g_variant_array(value);
  } else {
    ThrowException(Exception::Error(String::New("We haven't implemented this type yet!")));
  }

  return arguments;
}

/**
 * get_json_output:
 *
 * Should take as argument: GVariant value
 * Returns: The GVariant value as a JSON string
 */ 
static const gchar *
get_json_output (GVariant *value) {
  JsonNode *node;
  JsonGenerator *gen = json_generator_new ();

  node = json_gvariant_serialize (value);
  json_generator_set_root (gen, node);

  return json_generator_to_data (gen, NULL);
}

/**
 * dbus_call_sync:
 *
 * Should take as arguments:
 * 	bus_name: org.provider.Component (str)
 * 	object_path: /org/provider/Component (str)
 * 	interface_name: org.provider.Interface (str)
 * 	method_name: method_name (str)
 * 	parameters: string, integer, boolean or array
 * Returns: The DBus call returned value (if any) in a JSON string
 */
Handle<Value> 
dbus_call_sync(const Arguments& args) {
  HandleScope scope;
  GDBusConnection *session_bus;
  GError *error;
  GVariant *value;
  gboolean return_value;
  GVariant *arguments;
  GVariantBuilder builder;
  const gchar *json_output;

  /* Arguments */
  char bus_name[1024];
  char object_path[1024];
  char interface_name[1024];
  char method_name[1024];

  args[0]->ToString()->WriteAscii(bus_name);
  args[1]->ToString()->WriteAscii(object_path);
  args[2]->ToString()->WriteAscii(interface_name);
  args[3]->ToString()->WriteAscii(method_name);

  if (!(args[4]->IsNull())){
    arguments = get_g_variant_value (args[4]);
  } else {
    arguments = NULL;
  }

  error=NULL;

  session_bus = g_bus_get_sync(G_BUS_TYPE_SESSION, NULL, &error);
  
  value = g_dbus_connection_call_sync (session_bus, 
                                       bus_name,
                                       object_path,
                                       interface_name,
                                       method_name,
                                       arguments,
                                       NULL,
                                       G_DBUS_CALL_FLAGS_NONE,
                                       -1,
                                       NULL,
                                       &error);

  if (value == NULL) {
    g_printerr ("Error invoking %s: %s\n", method_name, error->message);
    g_error_free (error);
    exit(1);
  } else {
    json_output = get_json_output (value);
    g_variant_unref (value);
  }

  g_object_unref (session_bus);
  return scope.Close(String::New(json_output));
}


void init(Handle<Object> target) {
  g_type_init(); // Initialize gobject system
  target->Set(String::NewSymbol("dbus_call_sync"),
              FunctionTemplate::New(dbus_call_sync)->GetFunction());
}
NODE_MODULE(nodedbus, init)
